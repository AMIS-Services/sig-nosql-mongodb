-- import the HR records into the local MongoDB server (database hr and collections emp and dept)
-- note: the data is based on EMP and DEPT tables in SCOTT sample schema that used to be popular with Oracle Database 

mongoimport --host 127.0.0.1:27017 --db hr --collection emp --drop --file export_emp.csv  --type csv --fieldFile empFields.txt
mongoimport --host 127.0.0.1:27017 --db hr --collection dept --drop --file export_dept.csv  --type csv --fieldFile deptFields.txt

"C:\Program Files\MongoDB\Server\3.4\bin\mongoimport" --host 127.0.0.1:27017 --db hr --collection dept --drop --file export_dept.csv  --type csv --fieldFile deptFields.txt
"C:\Program Files\MongoDB\Server\3.4\bin\mongoimport" --host 127.0.0.1:27017 --db hr --collection emp --drop --file export_emp.csv  --type csv --fieldFile empFields.txt

-- run the mongodb shell

use hr

show collections

db.emp.stats()

-- find inspiration for queries at https://www.scribd.com/doc/24313549/Oracle-SQL-Queries-on-Emp-Table-1-to-235 

-- find the names of all managers
db.emp.find({"JOB":"MANAGER"},{ENAME:1})

-- find all salesmen, listed by salary descending
db.emp.find({"JOB":"SALESMAN"},{ENAME:1, SAL:1}).sort({'SAL':-1}) 

-- find all salesmen, listed by salary descending; only top 2
db.emp.find({"JOB":"SALESMAN"},{ENAME:1, SAL:1}).sort({'SAL':-1}).limit(2)

-- find all employees with AR in their name, sorted by name
db.emp.find({"ENAME":{$regex: "AR"} },{ENAME:1, SAL:1}).sort({'ENAME':1})

-- find all employees who are not in department 10, with their name and salary and sorted alphabetically by name
db.emp.find({"DEPTNO":{$ne: 10} },{ENAME:1, SAL:1, DEPTNO:1}).sort({'ENAME':1})

-- add a Date style property for hiredate
-- https://docs.mongodb.com/manual/reference/method/Date/, 
-- new Date("<YYYY-mm-dd>")
-- update documents based on values in document themselves

  db.emp.find().forEach(
      function (elem) {
        elem.startdate = new Date( "19"+ elem.HIREDATE.substring(6)
                       + "-" + elem.HIREDATE.substring(3,5)
                       + "-" + elem.HIREDATE.substring(0,2) 
                       );
        // don't forget to save the updated document
        db.emp.save(elem);
      }
    )

-- at this point, emp collection has documents with a startdate property that is a real Date() and not a string that looks like a date.
-- throw out the HIREDATE property

db.emp.update({}, { $unset: {HIREDATE : ""} })


-- list everyone hired after January 1st 1983 or later
db.emp.find(
{"startdate" :{$gt: new Date('1983-01-01') }}
)

-- list everyone hired in 1983 or later
db.emp.find(
{"startdate" :{$gt: new Date('1983') }}
)


-- using the aggregate framework we can use date and time operators like this https://smyl.es/how-to-use-mongodb-date-aggregation-operators-in-node-js-with-mongoose-dayofmonth-dayofyear-dayofweek-etc/ 

db.emp.aggregate(
 [ 
  {$project: {
        "ENAME": 1,
        "JOB": 1,
        "startdate": 1,
        "startmonth": { $month: "$startdate"}
    }
  }
]
)


use hr

-- create stored function

db.system.js.save({ 
   "_id": "squareThis", 
   "value": function(a) { return a*a } 
})

-- load function in current database

db.loadServerScripts();

-- invoke function in the shell

squareThis(10);

-- note: functions can be invoked in $where and $mapReduce
-- not in aggregate and find


-- some aggregates
-- total salary sum, total number of employees, the highest salary and the earliest startdate
db.emp.aggregate(
[{
     $group: {
        _id: null,
          total_salary_sum: { $sum: "$SAL" }
        , total_staff_count: { $sum: 1 }
        , max_sal: { $max: "$SAL" }
        , min_startdate: { $min: "$startdate" }
     }
   }
]
)

-- by department
db.emp.aggregate(
[{
     $group: {
        _id: "$DEPTNO",
          total_salary_sum: { $sum: "$SAL" }
        , total_staff_count: { $sum: 1 }
        , max_sal: { $max: "$SAL" }
        , min_startdate: { $min: "$startdate" }
     }
   }
]
)

-- by department and hireyear
db.emp.aggregate(
[{
     $group: {
        _id: { deptno: "$DEPTNO", hireyear : {  $year: "$startdate"} },
          total_salary_sum: { $sum: "$SAL" }
        , total_staff_count: { $sum: 1 }
        , max_sal: { $max: "$SAL" }
        , min_startdate: { $min: "$startdate" }
     }
   }
]
)


-- by department and hireyear
-- having more than one staff
db.emp.aggregate(
[{
     $group: {
        _id: { deptno: "$DEPTNO", hireyear : {  $year: "$startdate"} },
          total_salary_sum: { $sum: "$SAL" }
        , total_staff_count: { $sum: 1 }
        , max_sal: { $max: "$SAL" }
        , min_startdate: { $min: "$startdate" }
     }
   }
,   { $match: { total_staff_count: { $gt: 1 } } }
]
)


-- list all employees (empno and ename) along with the looked up department

db.emp.aggregate(
[  {$lookup:
      {
         from:"dept",
         localField:"DEPTNO",
         foreignField:"deptno",
         as:"dept"
     }
   }  
, {$project: {
        "EMPNO": 1,
        "ENAME": 1,
        "DEPT": { $arrayElemAt:["$dept", 0]},
      }
    }
]
)

-- list all departments with the list of their employees (name only)
db.dept.aggregate(
[  {$lookup:
      {
         from:"emp",
         localField:"deptno",
         foreignField:"DEPTNO",
         as:"emps"
     }
   }  
, {$project: {
        "deptno": 1,
        "dname": 1,
        "staff": { $reduce: {
                            input: "$emps",
                            initialValue: "",
                            in: { $concat : ["$$value", ", ","$$this.ENAME"] }
                           }
                 },
    }
  }
]
)



-- all employees who work in NEW YORK (after adding DEPT through lookup to each EMP)
db.emp.aggregate(
[  {$lookup:
      {
         from:"dept",
         localField:"DEPTNO",
         foreignField:"deptno",
         as:"dept"
     }
   }  
, {$project: {
        "EMPNO": 1,
        "ENAME": 1,
        "DEPT": { $arrayElemAt:["$dept", 0]},
      }
    }
, {$match: {  "DEPT.loc" :"NEW YORK"} }
]
)



-- all employees who work (directly) for KING

db.emp.aggregate(
[ 
 {$match: { ENAME: "KING"}}
, {$lookup:
      {
         from:"emp",
         localField:"EMPNO",
         foreignField:"MGR",
         as:"subordinates"
     }
   }  
, {$project: {
        "EMPNO": 1,
        "ENAME": 1,
        "subordinates": 1,
        // "firstStaff": { $arrayElemAt:["$staff", 0]},
        "staff": { $reduce: {
                            input: "$subordinates",
                            initialValue: "",
                            in: { $concat : ["$$value", ", ","$$this.ENAME"] }
                           }
                 },
      }
    }
]
)


-- in aggregations, we can make use of $facet.
-- here we use the facet operator to analyze our employees along several dimensions:  
-- JOB, SAL, DEPTNO and startdate

db.emp.aggregate( [
  {
    $facet: {
      "categorizedByJob": [
        { $sortByCount: "$JOB" }
      ],
     "categorizedBySalary": [
        {
          $bucket: {
            groupBy: "$SAL",
            boundaries: [0, 1000, 2000 ,3000 ,10000 ],
            default: "Other",
            output: {
              "count": { $sum: 1 },
              "employees": { $push: "$ENAME" }
            }
          }
        }
      ],
      "categorizedByDepartment": [
        { $sortByCount: "$DEPTNO" }
      ],
      "categorizedByHiredate(Auto)": [
        {
          $bucketAuto: {
            groupBy: "$startdate",
            buckets: 4
          }
        }
      ]
    }
  }
])




-- create new collection (similar to materialized view) from query
-- consisting of complex documents with department with array of nested employees
db.dept.aggregate(
[  {$lookup:
      {
         from:"emp",
         localField:"deptno",
         foreignField:"DEPTNO",
         as:"emps"
     }
   }  
, {$out: "departments" 
  }
]
)

-- inspect documents in departments
db.departments.find()

-- find department that contains employee named KING
db.departments.find( {"emps.ENAME":"KING"})

-- now to only find KING (and not all employees in the department)
db.departments.aggregate(
[
  {$unwind: {path:"$emps"}}  
, {$match: { "emps.ENAME": "KING"}}
, {$project: {
        "EMPNO": "$emps.EMPNO",
        "JOB": "$emps.JOB",
        "ENAME": "$emps.ENAME",
        "STARTDATE": "$emps.startdate",
        "DNAME": 1
    }
   }
]
)


-- find the names of all managers (in the complex documents with DEPT master and EMP details)
db.departments.aggregate(
[
  {$unwind: {path:"$emps"}}  
, {$match: { "emps.JOB": "MANAGER"}}
, {$project: {
        "ENAME": "$emps.ENAME",
    }
   }
]
)

-- find all employees who are not in department 10, with their name and salary and sorted alphabetically by name
db.departments.aggregate(
[
   {$match: { "DEPTNO": {$ne:10}}}
 , {$unwind: {path:"$emps"}}  
 , {$project: {
        "ENAME": "$emps.ENAME",
        "SAL": "$emps.SAL",
        "DEPTNO": 1,
    }
   }
 , {$sort : {"ENAME":1}}
]
)

-- against the nested documents, perform aggegration
-- total salary sum, total number of employees, the highest salary and the earliest startdate, per department

db.departments.aggregate(
[
   {$unwind: {path:"$emps"}}  
,  {$group:{ _id: '$deptno'
           , total_salary_sum : {$sum: "$emps.SAL"}
           , total_staff_count : {$sum: 1}
           , max_sal : {$max: "$emps.SAL"}
           , min_startdate : {$min: "$emps.startdate"}
           }
   }
]
)

-- add geospatial data for departments (longitude, lattitude)
db.dept.findAndModify({
    query: { loc: "NEW YORK" },
    update: { $set: { "location" : {
                         "type" : "Point",
                         "coordinates" : [ -73.935242, 40.730610 ]                         
                         } 
             } },
    upsert: true
})

db.dept.findAndModify({
    query: { loc: "DALLAS" },
    update: { $set: { "location" : {
                         "type" : "Point",
                         "coordinates" : [ -96.8005, 32.7801 ]                         
                         } 
             } },
    upsert: true
})

db.dept.findAndModify({
    query: { loc: "BOSTON" },
    update: { $set: { "location" : {
                         "type" : "Point",
                         "coordinates" : [ -71.0598, 42.3584 ]                         
                         } 
             } },
    upsert: true
})

db.dept.findAndModify({
    query: { loc: "CHICAGO" },
    update: { $set: { "location" : {
                         "type" : "Point",
                         "coordinates" : [ -87.6298, 41.8781 ]                         
                         } 
             } },
    upsert: true
})


-- create index 
db.dept.ensureIndex( { location : "2dsphere" } );

-- find departments within 500 km from Washington DC ( [ -77.0364, 38.8951 ])
-- NOTE: the $near operator requires an index.
db.dept.find(
  {
    location : {
      $near : {
        $geometry : { 
          type : "Point" , 
          coordinates : [ -77.0364, 38.8951 ] 
        }, 
        $maxDistance : 500000
      }
    }
  }
 )   

-- to also get the distance from Washington DC to the department(s), use aggregation with $geoNear
-- we find all points within 500000 meter from Washington DC and get the distance for each department in the property distanceFromTarget, in km (because of the distanceMultiplier that converts from meter to kilometer)
db.dept.aggregate([
    { "$geoNear": {
        "near": {
            "type": "Point",
            "coordinates": [ -77.0364, 38.8951 ] 
        }, 
        "maxDistance": 500000,
        "spherical": true,
        "distanceField": "distanceFromTarget",     
        "distanceMultiplier": 0.001
     }}
]).pretty()

-- to list all departments, ordered by their distance from Washington DC 
db.dept.aggregate([
    { "$geoNear": {
        "near": {
            "type": "Point",
            "coordinates": [ -77.0364, 38.8951 ] 
        }, 
        "spherical": true,
        "distanceField": "distanceFromTarget",     
        "distanceMultiplier": 0.001
     }}
 , {$sort : {"distanceFromTarget":1}}
,  {$project: {
        _id: 0,
        dname: 1,
        loc: 1,
        "distance from Washington DC": { $trunc : "$distanceFromTarget"},
    }
   }
])

